__author__ = 'tyler'

"""gd_sequence map: A class for storing information about mutations found in Genomediff files in predefined mappings.

This class is designed to simplify analysis and processing of Genomediff files. It stores the counts of various kinds
of mutations, organized in different dictionaries according to certain conditions; an example would be the type_map,
which organizes mutations by type.

This class is designed to work with the gd_sequence_mapper script. Details about that script can be found there or in
the documentation.

To add in future releases:
-integrate all possible mutation/evidence events generated by breseq tool

This file is part of gdparse.

    gdparse is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    gdparse is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with gdparse.  If not, see <http://www.gnu.org/licenses/>."""

import sys
class GenomeDiffSequenceMap:



    """__init__: instantiate all instance attributes"""
    def __init__(self):
        # Define mappings.
        self.type_map = dict()
        self.feat_map = dict()
        self.type_feat_map = dict()
        self.feat_type_map = dict()
        self.label_type_map = dict()

        # Initialize all counts to 0.
        self.total_count = 0
        return

    def get_count(self):
        return self.total_count

    def output_type_csv(self):

        mob_count = 0
        del_count = 0
        ins_count = 0
        snp_count = 0
        for _type in self.type_map:
            if _type == 'MOB':
                mob_count += self.type_map[_type]
            if _type == 'INS':
                ins_count += self.type_map[_type]
            if _type == 'DEL':
                del_count += self.type_map[_type]
            if _type == 'SNP':
                snp_count += self.type_map[_type]
        total_count = self.total_count

        return [mob_count, ins_count, del_count, snp_count]

    def output_label_csv(self):
        
        output_dict = dict()
        for label in self.feat_type_map:
            mob_count = 0
            del_count = 0
            ins_count = 0
            snp_count = 0
            for _type in self.feat_type_map[label]:
                if _type == 'MOB':
                    mob_count += self.type_map[_type]
                if _type == 'INS':
                    ins_count += self.type_map[_type]
                if _type == 'DEL':
                    del_count += self.type_map[_type]
                if _type == 'SNP':
                    snp_count += self.type_map[_type]
            output_dict[label] = [mob_count, ins_count, del_count, snp_count]
        total_count = self.total_count

        return [mob_count, ins_count, del_count, snp_count]
        
    
    def update_count(self):
        self.total_count += 1
        return

    def update_type_map(self, _type):
        if _type in self.type_map.keys():
            self.type_map[_type] += 1
        else:
            self.type_map.update({_type:1})
        return

    def update_feature_map(self, feat):
        if feat in self.feat_map.keys():
            self.feat_map[feat] += 1
        else:
            self.feat_map.update({feat:1})
        return

    def update_label_type_map(self, label, _type):
        if label in self.label_type_map.keys():
            return
        else:
            self.label_type_map.update({label:_type})
    def update_type_feat_map(self, _type, feat):
        if _type in self.type_feat_map.keys():
            if feat in self.type_feat_map[_type]:
                # Both keys exist in respective dictionaries
                self.type_feat_map[_type][feat] += 1
            else:
                # Need to add key 'feat' to type_feat_map[type] dict
                self.type_feat_map[_type].update({feat:1})
        # Must create type dictionary
        else:
            self.type_feat_map.update({_type:dict()})
            self.type_feat_map[_type].update({feat:1})
        return

    def update_feat_type_map(self, feat, _type):
        if feat in self.feat_type_map.keys():
            if _type in self.feat_type_map[feat].keys():
                # Both keys exist
                self.feat_type_map[feat][_type] += 1
            else:
                self.feat_type_map[feat].update({_type:1})
        # Create dictionaries
        else:
            self.feat_type_map.update({feat:dict()})
            self.feat_type_map[feat].update({_type:1})
        return
